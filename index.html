<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HAMMER.IO | TITAN PROTOCOL</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        /* =========================================
           CORE VISUALS & RESET
           ========================================= */
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-gold: #ffd700;
            --bg-dark: #0a0a12;
            --ui-bg: rgba(10, 10, 18, 0.95);
            --border: 1px solid rgba(255, 255, 255, 0.1);
        }

        * { box-sizing: border-box; user-select: none; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #000; overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            color: white;
        }

        /* =========================================
           UI: LOBBY & MENUS
           ========================================= */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            display: flex; align-items: center; justify-content: center;
            z-index: 999;
        }

        .panel {
            width: 450px; padding: 40px;
            background: var(--ui-bg);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            text-align: center;
            position: relative;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        h1 {
            font-size: 64px; margin: 0 0 10px; line-height: 0.8;
            background: linear-gradient(90deg, #fff, var(--neon-blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 2px;
        }
        
        .version { font-size: 12px; color: #555; margin-bottom: 30px; letter-spacing: 5px; }

        .input-group { margin-bottom: 20px; position: relative; }
        
        input {
            width: 100%; background: rgba(255,255,255,0.05);
            border: 1px solid #333; color: var(--neon-blue);
            padding: 15px; font-size: 20px; text-align: center;
            font-family: inherit; outline: none; transition: 0.3s;
        }
        input:focus { border-color: var(--neon-blue); box-shadow: 0 0 15px rgba(0, 243, 255, 0.2); }

        button {
            width: 100%; padding: 20px; font-size: 24px; font-weight: 900;
            background: var(--neon-blue); color: #000; border: none;
            cursor: pointer; transition: 0.2s; text-transform: uppercase;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 95% 100%, 0 100%);
        }
        button:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 243, 255, 0.4); }

        .server-status {
            margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;
            display: flex; justify-content: space-between; font-size: 14px; color: #888;
        }

        /* =========================================
           UI: HUD (HEADS UP DISPLAY)
           ========================================= */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none;
        }

        /* Top Bar */
        .top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px;
        }
        .stat-badge {
            background: rgba(0,0,0,0.6); padding: 10px 25px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 20px; font-weight: 700; color: #fff;
            display: flex; align-items: center; gap: 10px;
        }
        #timer-display { color: var(--neon-red); min-width: 80px; justify-content: center; }

        /* Minimap */
        #minimap-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 150px; height: 150px;
            background: rgba(0,0,0,0.5); border: 2px solid #333;
            border-radius: 50%; overflow: hidden;
        }
        #minimap { width: 100%; height: 100%; opacity: 0.8; }

        /* Ammo */
        #ammo-rack {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px;
        }
        .ammo-slug {
            width: 16px; height: 40px; background: var(--neon-gold);
            transform: skewX(-20deg); box-shadow: 0 0 15px var(--neon-gold);
            transition: 0.2s;
        }
        .ammo-slug.empty { background: #333; box-shadow: none; opacity: 0.3; }

        /* Kill Feed */
        #killfeed {
            position: absolute; top: 20px; right: 20px;
            text-align: right; display: flex; flex-direction: column; gap: 5px;
        }
        .kill-msg {
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8));
            padding: 5px 15px; font-size: 14px; color: #fff;
            animation: slideIn 0.3s ease-out;
        }
        .kill-msg b { color: var(--neon-red); }

        /* Leaderboard */
        #leaderboard {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.5); padding: 15px;
            border-left: 3px solid var(--neon-blue);
        }
        .lb-row { font-size: 14px; margin-bottom: 4px; color: #ccc; }
        .lb-row.me { color: var(--neon-blue); font-weight: bold; }

        @keyframes slideIn { from { transform: translateX(50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        /* Death Screen overlay */
        #death-screen {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(255, 0, 85, 0.2);
            display: none; align-items: center; justify-content: center; z-index: 50;
            backdrop-filter: blur(5px);
        }
        .wasted { font-size: 80px; color: var(--neon-red); font-weight: 900; text-shadow: 0 0 30px black; }

        canvas { display: block; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="panel">
            <h1>HAMMER<span>.IO</span></h1>
            <div class="version">TITAN BUILD v9.0</div>
            
            <div class="input-group">
                <input type="text" id="nick" placeholder="OPERATOR NAME" maxlength="12">
            </div>
            
            <button onclick="Game.init()">INITIALIZE</button>

            <div class="server-status">
                <span>STATUS: <b style="color:#0f0">ONLINE</b></span>
                <span>PLAYERS: <b id="lobby-count" style="color:#fff">...</b></span>
            </div>
            <div id="lobby-list" style="margin-top:15px; height: 100px; overflow-y: auto; text-align: left; font-size: 12px; color: #666; border: 1px solid #222; padding: 10px;">
                Connecting...
            </div>
        </div>
    </div>

    <div id="hud-layer">
        <div class="top-bar">
            <div class="stat-badge">SCORE <span id="score-val" style="color:var(--neon-blue)">0</span></div>
            <div class="stat-badge" id="timer-display">--</div>
            <div class="stat-badge">KILLS <span id="kills-val" style="color:var(--neon-red)">0</span></div>
        </div>

        <div id="leaderboard">
            <div style="font-size:10px; color:#666; margin-bottom:5px;">SECTOR TOP</div>
            <div id="lb-content"></div>
        </div>

        <div id="killfeed"></div>
        <div id="ammo-rack"></div>

        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>
    </div>

    <div id="death-screen">
        <div class="wasted">CRITICAL FAILURE</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        /**
         * ====================================================================
         * HAMMER.IO TITAN ENGINE
         * ====================================================================
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            mapWidth: 2000,
            mapHeight: 2000,
            cameraSmooth: 0.1,
            hammerSpeed: 28,
            botCount: 8, // Количество ботов
            colors: {
                me: '#00f3ff',
                enemy: '#ffffff',
                hunter: '#ff0055',
                bot: '#8888aa'
            }
        };

        const KEYS = {
            k: "QUl6YVN5QV80a1pkLUFTRVhBQXEtR2NrYzJqeTZsaWpQTFF6S20w",
            d: "aGFtbWVyY3Vycy1pby5maXJlYmFzZWFwcC5jb20=",
            u: "aHR0cHM6Ly9oYW1tZXJjdXJzLWlvLWRlZmF1bHQtcnRkYi5ldXJvcGUtd2VzdDEuZmlyZWJhc2VkYXRhYmFzZS5hcHA=",
            p: "aGFtbWVyY3Vycy1pbw==",
            s: "aGFtbWVyY3Vycy1pby5maXJlYmFzZXN0b3JhZ2UuYXBw",
            m: "MTA1MTg5OTk2MDk3Mw==",
            a: "MToxMDUxODk5OTYwOTczOndlYjoxNDIzNTg1YTFhMjFkN2ZmMTMwY2M0"
        };

        // --- FIREBASE INIT ---
        const app = initializeApp({
            apiKey: atob(KEYS.k), authDomain: atob(KEYS.d), databaseURL: atob(KEYS.u),
            projectId: atob(KEYS.p), storageBucket: atob(KEYS.s), messagingSenderId: atob(KEYS.m), appId: atob(KEYS.a)
        });
        const db = getDatabase(app);

        // --- GAME STATE ---
        const State = {
            myId: Math.random().toString(36).substring(7),
            nick: "Unknown",
            players: {},
            hammers: [],
            particles: [],
            messages: [], // Chat messages from bots
            camera: { x: 0, y: 0 },
            mouse: { x: 0, y: 0, worldX: 0, worldY: 0, down: false },
            isHunter: false,
            ammo: 3,
            rotation: 0,
            score: 0,
            kills: 0,
            shake: 0,
            hunterStart: 0,
            alive: true
        };

        // --- CANVAS SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mmCanvas = document.getElementById('minimap');
        const mmCtx = mmCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            mmCanvas.width = 150;
            mmCanvas.height = 150;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ASSETS (PROCEDURAL) ---
        const HammerPath = new Path2D("M-35 -20 L35 -20 L40 10 L-40 10 Z M-12 10 L12 10 L12 70 L-12 70 Z");

        // --- BOT AI SYSTEM ---
        class BotSystem {
            constructor() {
                this.bots = [];
                this.names = ["X-RAY", "Viper", "Ghost", "Zero", "Neon", "Kilo", "Delta", "Echo"];
            }

            init() {
                for(let i=0; i<CONFIG.botCount; i++) {
                    this.bots.push({
                        id: 'bot_'+i,
                        nick: this.names[i % this.names.length],
                        x: Math.random() * CONFIG.mapWidth,
                        y: Math.random() * CONFIG.mapHeight,
                        vx: (Math.random()-0.5)*4,
                        vy: (Math.random()-0.5)*4,
                        angle: 0,
                        isHunter: false,
                        status: 'ALIVE',
                        changeDirTimer: 0
                    });
                }
            }

            update() {
                this.bots.forEach(b => {
                    if(b.status === 'DEAD') return;

                    // AI Logic: Movement
                    b.changeDirTimer--;
                    if(b.changeDirTimer <= 0) {
                        b.vx = (Math.random()-0.5) * 6;
                        b.vy = (Math.random()-0.5) * 6;
                        b.changeDirTimer = 50 + Math.random() * 100;
                    }

                    // Keep in bounds
                    b.x += b.vx; b.y += b.vy;
                    if(b.x < 0) b.x = 0; if(b.x > CONFIG.mapWidth) b.x = CONFIG.mapWidth;
                    if(b.y < 0) b.y = 0; if(b.y > CONFIG.mapHeight) b.y = CONFIG.mapHeight;

                    // Fake Rotation
                    b.angle += 0.05;
                });
            }
        }
        const Bots = new BotSystem();

        // --- MAIN GAME CLASS ---
        const Game = {
            init: function() {
                const input = document.getElementById('nick').value;
                State.nick = input.toUpperCase() || "UNIT_" + State.myId.substr(0,3);

                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('hud-layer').style.display = 'block';

                // Spawn at random location
                const startX = Math.random() * CONFIG.mapWidth;
                const startY = Math.random() * CONFIG.mapHeight;

                const myRef = ref(db, `rooms/global/players/${State.myId}`);
                set(myRef, {
                    nick: State.nick, x: startX, y: startY,
                    isHunter: false, status: 'ALIVE', score: 0
                });
                onDisconnect(myRef).remove();

                // Start sub-systems
                if(Object.keys(State.players).length === 0) Bots.init();
                
                this.loop();
            },

            // CORE LOOP
            loop: function() {
                if(!State.alive) return;

                // 1. Logic
                Game.updateCamera();
                Bots.update();
                Game.updateProjectiles();
                Game.updateParticles();
                
                // 2. Input Sync
                State.mouse.worldX = State.mouse.x + State.camera.x;
                State.mouse.worldY = State.mouse.y + State.camera.y;
                
                // Send data to server (throttled implicitly by animation frame, could be optimized)
                const myRef = ref(db, `rooms/global/players/${State.myId}`);
                // Simple prediction for self
                if(State.players[State.myId]) {
                   // Move logic could be here if we had WASD, but we track mouse for hammer
                   // Assuming player follows mouse roughly or stays still? 
                   // For this mode, let's say player moves towards mouse slowly
                   const dx = State.mouse.worldX - State.players[State.myId].x;
                   const dy = State.mouse.worldY - State.players[State.myId].y;
                   const dist = Math.sqrt(dx*dx + dy*dy);
                   if(dist > 10) {
                       State.players[State.myId].x += (dx/dist) * 4;
                       State.players[State.myId].y += (dy/dist) * 4;
                   }
                   update(myRef, { x: Math.round(State.players[State.myId].x), y: Math.round(State.players[State.myId].y) });
                }

                // 3. Render
                Game.render();
                Game.renderMinimap();

                requestAnimationFrame(Game.loop);
            },

            updateCamera: function() {
                if(!State.players[State.myId]) return;
                const me = State.players[State.myId];
                
                // Shake effect
                let shakeX = 0, shakeY = 0;
                if(State.shake > 0) {
                    shakeX = (Math.random()-0.5) * State.shake;
                    shakeY = (Math.random()-0.5) * State.shake;
                    State.shake *= 0.9;
                }

                // Smooth follow
                const targetX = me.x - canvas.width/2;
                const targetY = me.y - canvas.height/2;
                
                State.camera.x += (targetX - State.camera.x) * CONFIG.cameraSmooth + shakeX;
                State.camera.y += (targetY - State.camera.y) * CONFIG.cameraSmooth + shakeY;
            },

            updateProjectiles: function() {
                State.hammers.forEach((h, i) => {
                    h.x += h.vx; h.y += h.vy; h.life--;
                    
                    if(h.life <= 0) {
                        State.hammers.splice(i, 1);
                        Game.explode(h.x, h.y, h.angle);
                        
                        if(State.isHunter) {
                            // Collision Check (Players)
                            Object.keys(State.players).forEach(pid => {
                                if(pid !== State.myId && !State.players[pid].isHunter && State.players[pid].status === 'ALIVE') {
                                    if(Game.dist(h.x, h.y, State.players[pid].x, State.players[pid].y) < 70) {
                                        update(ref(db, `rooms/global/players/${pid}`), { status: 'DEAD' });
                                        Game.addScore(300);
                                        Game.addKillFeed("YOU", State.players[pid].nick);
                                    }
                                }
                            });
                            // Collision Check (Bots)
                            Bots.bots.forEach(b => {
                                if(b.status === 'ALIVE' && !b.isHunter && Game.dist(h.x, h.y, b.x, b.y) < 70) {
                                    b.status = 'DEAD';
                                    Game.addScore(150);
                                    Game.explode(b.x, b.y, 0, '#888');
                                    Game.addKillFeed("YOU", b.nick);
                                }
                            });
                        }
                    }
                });
            },

            updateParticles: function() {
                State.particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life -= 0.04;
                    if(p.life <= 0) State.particles.splice(i, 1);
                });
            },

            render: function() {
                // Clear
                ctx.fillStyle = "#0a0a12";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(-State.camera.x, -State.camera.y);

                // Grid
                ctx.strokeStyle = "rgba(255,255,255,0.03)";
                ctx.lineWidth = 2;
                const gridSize = 100;
                const startX = Math.floor(State.camera.x / gridSize) * gridSize;
                const startY = Math.floor(State.camera.y / gridSize) * gridSize;
                
                for(let x = startX; x < startX + canvas.width + gridSize; x += gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, State.camera.y); ctx.lineTo(x, State.camera.y + canvas.height); ctx.stroke();
                }
                for(let y = startY; y < startY + canvas.height + gridSize; y += gridSize) {
                    ctx.beginPath(); ctx.moveTo(State.camera.x, y); ctx.lineTo(State.camera.x + canvas.width, y); ctx.stroke();
                }

                // Map Borders
                ctx.strokeStyle = "#ff0055"; ctx.lineWidth = 5;
                ctx.strokeRect(0, 0, CONFIG.mapWidth, CONFIG.mapHeight);

                // Draw Entities (Bots + Players)
                const allEntities = [...Object.values(State.players), ...Bots.bots];
                
                allEntities.forEach(e => {
                    if(e.status === 'DEAD') return;
                    
                    const isMe = e.nick === State.nick;
                    const color = e.isHunter ? CONFIG.colors.hunter : (isMe ? CONFIG.colors.me : (e.id && e.id.includes('bot') ? CONFIG.colors.bot : CONFIG.colors.enemy));

                    // Glow
                    ctx.shadowBlur = 20; ctx.shadowColor = color;
                    ctx.fillStyle = color;
                    
                    // Body
                    ctx.beginPath(); ctx.arc(e.x, e.y, 16, 0, Math.PI*2); ctx.fill();
                    
                    // Ring
                    ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(e.x, e.y, 22, 0, Math.PI*2); ctx.stroke();

                    // Name
                    ctx.shadowBlur = 0; ctx.fillStyle = "white"; 
                    ctx.font = "bold 12px Rajdhani"; ctx.textAlign = "center";
                    ctx.fillText(e.nick, e.x, e.y - 35);
                    
                    // Health Bar (Fake)
                    ctx.fillStyle = "#333"; ctx.fillRect(e.x-15, e.y-30, 30, 4);
                    ctx.fillStyle = "#0f0"; ctx.fillRect(e.x-15, e.y-30, 30, 4);
                });

                // Draw Hammers
                if(State.isHunter) {
                    State.rotation += 0.3;
                    const me = State.players[State.myId];
                    if(me) {
                        ctx.save(); ctx.translate(me.x, me.y);
                        // Rotate towards mouse
                        const angle = Math.atan2(State.mouse.worldY - me.y, State.mouse.worldX - me.x);
                        ctx.rotate(angle);
                        ctx.translate(20, 0); // Offset from body
                        ctx.rotate(State.rotation); // Spin
                        
                        ctx.fillStyle = "#ffd700"; ctx.shadowBlur = 15; ctx.shadowColor = "#ffd700";
                        ctx.fill(HammerPath);
                        ctx.restore();
                    }
                }

                // Flying Projectiles
                State.hammers.forEach(h => {
                    ctx.save(); ctx.translate(h.x, h.y); ctx.rotate(h.angle);
                    ctx.fillStyle = "#ff4757"; ctx.shadowBlur = 20; ctx.shadowColor = "red";
                    ctx.fill(HammerPath);
                    ctx.restore();
                });

                // Particles
                State.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.c;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                });
                ctx.globalAlpha = 1;

                ctx.restore();
            },

            renderMinimap: function() {
                mmCtx.clearRect(0, 0, 150, 150);
                mmCtx.fillStyle = "rgba(0,0,0,0.8)";
                mmCtx.fillRect(0, 0, 150, 150);
                
                const scaleX = 150 / CONFIG.mapWidth;
                const scaleY = 150 / CONFIG.mapHeight;

                [...Object.values(State.players), ...Bots.bots].forEach(e => {
                    if(e.status === 'DEAD') return;
                    mmCtx.fillStyle = e.isHunter ? '#f00' : (e.nick === State.nick ? '#0ff' : '#fff');
                    mmCtx.beginPath();
                    mmCtx.arc(e.x * scaleX, e.y * scaleY, 2, 0, Math.PI*2);
                    mmCtx.fill();
                });
            },

            // UTILS
            dist: (x1,y1,x2,y2) => Math.hypot(x2-x1, y2-y1),
            
            explode: function(x, y, angle, color) {
                State.shake = 20;
                for(let i=0; i<15; i++) {
                    State.particles.push({
                        x, y, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                        life: 1, size: Math.random()*4, c: color || (State.isHunter ? '#ffd700' : '#0ff')
                    });
                }
            },

            addScore: function(val) {
                State.score += val;
                State.kills++;
                update(ref(db, `rooms/global/players/${State.myId}`), { score: State.score });
                document.getElementById('score-val').innerText = State.score;
                document.getElementById('kills-val').innerText = State.kills;
            },

            addKillFeed: function(killer, victim) {
                const feed = document.getElementById('killfeed');
                const div = document.createElement('div');
                div.className = 'kill-msg';
                div.innerHTML = `<b>${killer}</b> TERMINATED ${victim}`;
                feed.prepend(div);
                if(feed.children.length > 5) feed.lastChild.remove();
                setTimeout(() => div.remove(), 4000);
            }
        };

        // --- GLOBAL EVENTS ---
        window.Game = Game; // Expose for button

        window.addEventListener('mousemove', e => {
            State.mouse.x = e.clientX; State.mouse.y = e.clientY;
        });

        window.addEventListener('mousedown', () => { if(State.isHunter && State.ammo > 0) State.mouse.down = true; });
        window.addEventListener('mouseup', () => { 
            if(State.mouse.down) { 
                State.mouse.down = false;
                State.ammo--;
                Game.updateAmmoUI();
                
                // Shoot Math
                const me = State.players[State.myId];
                if(me) {
                    const angle = Math.atan2(State.mouse.worldY - me.y, State.mouse.worldX - me.x);
                    State.hammers.push({
                        x: me.x, y: me.y,
                        vx: Math.cos(angle) * CONFIG.hammerSpeed,
                        vy: Math.sin(angle) * CONFIG.hammerSpeed,
                        angle: angle, life: 50
                    });
                }
            } 
        });

        Game.updateAmmoUI = function() {
            const rack = document.getElementById('ammo-rack'); rack.innerHTML = '';
            for(let i=0; i<3; i++) rack.innerHTML += `<div class="ammo-slug ${i<State.ammo?'':'empty'}"></div>`;
        };

        // --- FIREBASE LISTENERS ---
        onValue(ref(db, `rooms/global/players`), snap => {
            const data = snap.val() || {};
            State.players = data;

            // Lobby List Update
            const list = document.getElementById('lobby-list');
            const count = document.getElementById('lobby-count');
            if(list && count) {
                list.innerHTML = '';
                const keys = Object.keys(data);
                count.innerText = keys.length;
                keys.forEach(id => { list.innerHTML += `<div>> UNIT: ${data[id].nick} [${data[id].score||0} PTS]</div>` });
            }

            // Game Logic Updates
            if(data[State.myId]?.status === 'DEAD') {
                document.getElementById('death-screen').style.display = 'flex';
                State.alive = false;
                setTimeout(() => location.reload(), 2000);
            }

            // Leaderboard
            const lb = document.getElementById('lb-content');
            if(lb) {
                lb.innerHTML = '';
                Object.values(data).sort((a,b)=>(b.score||0)-(a.score||0)).slice(0,5).forEach(p => {
                    lb.innerHTML += `<div class="lb-row ${p.nick===State.nick?'me':''}">${p.nick}: ${p.score||0}</div>`;
                });
            }

            // Hunter Logic
            const hunterId = Object.keys(data).find(id => data[id].isHunter);
            if(!hunterId && Object.keys(data).length > 0) {
                 update(ref(db, `rooms/global/players/${Object.keys(data)[0]}`), { isHunter: true, t: Date.now() });
            }

            const me = data[State.myId];
            if(me?.isHunter) {
                if(!State.isHunter) { 
                    State.isHunter = true; State.ammo = 3; State.hunterStart = Date.now(); Game.updateAmmoUI(); 
                    Game.addKillFeed("SYSTEM", "YOU ARE THE HUNTER");
                }
                let t = Math.max(0, 15 - (Date.now() - State.hunterStart)/1000).toFixed(1);
                document.getElementById('timer-display').innerText = t;
                if(t <= 0) update(ref(db, `rooms/global/players/${State.myId}`), { status: 'DEAD' });
            } else {
                State.isHunter = false; 
                document.getElementById('timer-display').innerText = "SURVIVE";
            }
        });

    </script>
</body>
</html>
